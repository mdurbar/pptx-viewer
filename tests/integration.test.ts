/**
 * Integration tests using real PPTX files.
 *
 * These tests verify the complete parsing pipeline with actual
 * PowerPoint files generated by python-pptx.
 */

import { describe, it, expect, beforeAll } from 'vitest';
import { readFileSync } from 'fs';
import { join } from 'path';
import { extractPPTX } from '../src/core/unzip';
import { parsePPTX, isValidPPTX, getSlideCount } from '../src/parser/PPTXParser';
import type { Presentation, ShapeElement, TextElement, TableElement } from '../src/core/types';

const FIXTURES_DIR = join(__dirname, 'fixtures');

/**
 * Helper to load a PPTX file from fixtures.
 */
async function loadFixture(filename: string): Promise<Presentation> {
  const filePath = join(FIXTURES_DIR, filename);
  const buffer = readFileSync(filePath);
  // Convert Node.js Buffer to Uint8Array
  const uint8Array = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  const archive = await extractPPTX(uint8Array);
  return parsePPTX(archive);
}

/**
 * Helper to get archive from fixture.
 */
async function getArchive(filename: string) {
  const filePath = join(FIXTURES_DIR, filename);
  const buffer = readFileSync(filePath);
  // Convert Node.js Buffer to Uint8Array
  const uint8Array = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  return extractPPTX(uint8Array);
}

describe('Integration Tests', () => {
  describe('Basic Shapes PPTX', () => {
    let presentation: Presentation;

    beforeAll(async () => {
      presentation = await loadFixture('basic-shapes.pptx');
    });

    it('loads successfully', () => {
      expect(presentation).toBeDefined();
      expect(presentation.slides).toHaveLength(1);
    });

    it('has correct slide dimensions', () => {
      expect(presentation.slideSize.width).toBeGreaterThan(0);
      expect(presentation.slideSize.height).toBeGreaterThan(0);
    });

    it('contains multiple shapes', () => {
      const slide = presentation.slides[0];
      expect(slide.elements.length).toBeGreaterThan(5);
    });

    it('parses rectangle shape', () => {
      const slide = presentation.slides[0];
      const shapes = slide.elements.filter(
        (el): el is ShapeElement => el.type === 'shape'
      );

      const rect = shapes.find(s => s.shapeType === 'rect');
      expect(rect).toBeDefined();
      expect(rect?.fill).toBeDefined();
    });

    it('parses rounded rectangle shape', () => {
      const slide = presentation.slides[0];
      const shapes = slide.elements.filter(
        (el): el is ShapeElement => el.type === 'shape'
      );

      const roundRect = shapes.find(s => s.shapeType === 'roundRect');
      expect(roundRect).toBeDefined();
    });

    it('parses ellipse shape', () => {
      const slide = presentation.slides[0];
      const shapes = slide.elements.filter(
        (el): el is ShapeElement => el.type === 'shape'
      );

      const ellipse = shapes.find(s => s.shapeType === 'ellipse');
      expect(ellipse).toBeDefined();
    });

    it('parses star shape', () => {
      const slide = presentation.slides[0];
      const shapes = slide.elements.filter(
        (el): el is ShapeElement => el.type === 'shape'
      );

      const star = shapes.find(s => s.shapeType?.startsWith('star'));
      expect(star).toBeDefined();
    });

    it('parses arrow shape', () => {
      const slide = presentation.slides[0];
      const shapes = slide.elements.filter(
        (el): el is ShapeElement => el.type === 'shape'
      );

      const arrow = shapes.find(s =>
        s.shapeType === 'rightArrow' || s.shapeType === 'arrow'
      );
      expect(arrow).toBeDefined();
    });

    it('parses solid fill colors', () => {
      const slide = presentation.slides[0];
      const shapes = slide.elements.filter(
        (el): el is ShapeElement => el.type === 'shape' && el.fill?.type === 'solid'
      );

      expect(shapes.length).toBeGreaterThan(0);
      shapes.forEach(shape => {
        if (shape.fill?.type === 'solid') {
          expect(shape.fill.color.hex).toMatch(/^#[0-9A-Fa-f]{6}$/);
        }
      });
    });
  });

  describe('Text Formatting PPTX', () => {
    let presentation: Presentation;

    beforeAll(async () => {
      presentation = await loadFixture('text-formatting.pptx');
    });

    it('loads successfully', () => {
      expect(presentation).toBeDefined();
      expect(presentation.slides).toHaveLength(1);
    });

    it('contains text elements', () => {
      const slide = presentation.slides[0];
      const textElements = slide.elements.filter(
        (el): el is TextElement | ShapeElement =>
          el.type === 'text' || (el.type === 'shape' && !!el.text)
      );

      expect(textElements.length).toBeGreaterThan(0);
    });

    it('parses text runs with formatting', () => {
      const slide = presentation.slides[0];
      let foundFormatting = false;

      for (const el of slide.elements) {
        const text = el.type === 'text' ? el.text : (el as ShapeElement).text;
        if (!text) continue;

        for (const para of text.paragraphs) {
          for (const run of para.runs) {
            if (run.bold || run.italic || run.underline) {
              foundFormatting = true;
            }
          }
        }
      }

      expect(foundFormatting).toBe(true);
    });

    it('parses colored text', () => {
      const slide = presentation.slides[0];
      let foundColor = false;

      for (const el of slide.elements) {
        const text = el.type === 'text' ? el.text : (el as ShapeElement).text;
        if (!text) continue;

        for (const para of text.paragraphs) {
          for (const run of para.runs) {
            if (run.color) {
              foundColor = true;
              expect(run.color.hex).toMatch(/^#[0-9A-Fa-f]{6}$/);
            }
          }
        }
      }

      expect(foundColor).toBe(true);
    });

    it('parses different font sizes', () => {
      const slide = presentation.slides[0];
      const fontSizes = new Set<number>();

      for (const el of slide.elements) {
        const text = el.type === 'text' ? el.text : (el as ShapeElement).text;
        if (!text) continue;

        for (const para of text.paragraphs) {
          for (const run of para.runs) {
            if (run.fontSize) {
              fontSizes.add(run.fontSize);
            }
          }
        }
      }

      expect(fontSizes.size).toBeGreaterThan(1);
    });
  });

  describe('Gradients PPTX', () => {
    let presentation: Presentation;

    beforeAll(async () => {
      presentation = await loadFixture('gradients.pptx');
    });

    it('loads successfully', () => {
      expect(presentation).toBeDefined();
    });

    it('parses gradient fills', () => {
      const slide = presentation.slides[0];
      const gradientShapes = slide.elements.filter(
        (el): el is ShapeElement =>
          el.type === 'shape' && el.fill?.type === 'gradient'
      );

      expect(gradientShapes.length).toBeGreaterThan(0);
    });

    it('gradient has color stops', () => {
      const slide = presentation.slides[0];
      const gradientShape = slide.elements.find(
        (el): el is ShapeElement =>
          el.type === 'shape' && el.fill?.type === 'gradient'
      );

      expect(gradientShape).toBeDefined();
      if (gradientShape?.fill?.type === 'gradient') {
        expect(gradientShape.fill.stops.length).toBeGreaterThanOrEqual(2);
        gradientShape.fill.stops.forEach(stop => {
          expect(stop.position).toBeGreaterThanOrEqual(0);
          expect(stop.position).toBeLessThanOrEqual(1);
          expect(stop.color.hex).toMatch(/^#[0-9A-Fa-f]{6}$/);
        });
      }
    });

    it('gradient has angle', () => {
      const slide = presentation.slides[0];
      const gradientShape = slide.elements.find(
        (el): el is ShapeElement =>
          el.type === 'shape' && el.fill?.type === 'gradient'
      );

      expect(gradientShape).toBeDefined();
      if (gradientShape?.fill?.type === 'gradient') {
        expect(typeof gradientShape.fill.angle).toBe('number');
      }
    });
  });

  describe('Tables PPTX', () => {
    let presentation: Presentation;

    beforeAll(async () => {
      presentation = await loadFixture('tables.pptx');
    });

    it('loads successfully', () => {
      expect(presentation).toBeDefined();
    });

    it('parses table element', () => {
      const slide = presentation.slides[0];
      const tables = slide.elements.filter(
        (el): el is TableElement => el.type === 'table'
      );

      expect(tables.length).toBeGreaterThan(0);
    });

    it('table has rows and cells', () => {
      const slide = presentation.slides[0];
      const table = slide.elements.find(
        (el): el is TableElement => el.type === 'table'
      );

      expect(table).toBeDefined();
      expect(table?.rows.length).toBeGreaterThan(0);
      expect(table?.rows[0].cells.length).toBeGreaterThan(0);
    });

    it('table cells have text content', () => {
      const slide = presentation.slides[0];
      const table = slide.elements.find(
        (el): el is TableElement => el.type === 'table'
      );

      expect(table).toBeDefined();

      let foundText = false;
      for (const row of table?.rows || []) {
        for (const cell of row.cells) {
          if (cell.text?.paragraphs.some(p => p.runs.some(r => r.text))) {
            foundText = true;
          }
        }
      }

      expect(foundText).toBe(true);
    });

    it('table has column widths', () => {
      const slide = presentation.slides[0];
      const table = slide.elements.find(
        (el): el is TableElement => el.type === 'table'
      );

      expect(table).toBeDefined();
      expect(table?.columnWidths.length).toBeGreaterThan(0);
      table?.columnWidths.forEach(width => {
        expect(width).toBeGreaterThan(0);
      });
    });
  });

  describe('Multi-Slide PPTX', () => {
    let presentation: Presentation;

    beforeAll(async () => {
      presentation = await loadFixture('multi-slide.pptx');
    });

    it('loads successfully', () => {
      expect(presentation).toBeDefined();
    });

    it('has multiple slides', () => {
      expect(presentation.slides.length).toBe(3);
    });

    it('slides have correct indices', () => {
      presentation.slides.forEach((slide, idx) => {
        expect(slide.index).toBe(idx);
      });
    });

    it('each slide has elements', () => {
      presentation.slides.forEach(slide => {
        expect(slide.elements.length).toBeGreaterThan(0);
      });
    });
  });

  describe('Comprehensive PPTX', () => {
    let presentation: Presentation;

    beforeAll(async () => {
      presentation = await loadFixture('comprehensive.pptx');
    });

    it('loads successfully', () => {
      expect(presentation).toBeDefined();
    });

    it('has theme colors', () => {
      expect(presentation.theme.colors).toBeDefined();
      expect(presentation.theme.colors.accent1).toBeDefined();
    });

    it('has theme fonts', () => {
      expect(presentation.theme.fonts).toBeDefined();
      expect(presentation.theme.fonts.major).toBeDefined();
      expect(presentation.theme.fonts.minor).toBeDefined();
    });

    it('contains various element types', () => {
      const slide = presentation.slides[0];

      const shapeCount = slide.elements.filter(el => el.type === 'shape').length;
      const textCount = slide.elements.filter(el => el.type === 'text').length;
      const tableCount = slide.elements.filter(el => el.type === 'table').length;

      expect(shapeCount + textCount + tableCount).toBeGreaterThan(5);
    });
  });

  describe('Archive Validation', () => {
    it('validates basic-shapes.pptx as valid', async () => {
      const archive = await getArchive('basic-shapes.pptx');
      expect(isValidPPTX(archive)).toBe(true);
    });

    it('correctly counts slides', async () => {
      const archive = await getArchive('multi-slide.pptx');
      expect(getSlideCount(archive)).toBe(3);
    });
  });

  describe('Element Bounds', () => {
    it('all elements have valid bounds', async () => {
      const presentation = await loadFixture('comprehensive.pptx');

      for (const slide of presentation.slides) {
        for (const element of slide.elements) {
          expect(element.bounds).toBeDefined();
          expect(element.bounds.x).toBeGreaterThanOrEqual(0);
          expect(element.bounds.y).toBeGreaterThanOrEqual(0);
          expect(element.bounds.width).toBeGreaterThan(0);
          expect(element.bounds.height).toBeGreaterThan(0);
        }
      }
    });
  });
});
